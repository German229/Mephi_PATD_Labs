\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\geometry{margin=1in}
\begin{document}

\section{Введение}
\label{sec:intro}

ProbabilityScript --- это специализированный язык сценариев, предназначенный для упрощения описания и выполнения вероятностных экспериментов и статистических вычислений. 
Он предоставляет минималистичный синтаксис для моделирования случайных процессов, сбора выборочных данных и расчёта статистических характеристик. 
Данный язык и его интерпретатор разработаны с целью облегчить исследование концепций теории вероятностей и математической статистики, 
позволяя пользователю фокусироваться на постановке задачи, а не на низкоуровневых деталях реализации.

Основная сфера применения ProbabilityScript --- учебные и исследовательские задачи, требующие проведения множества повторяющихся симуляций, вычисления таких величин, 
как средние значения, дисперсии, медианы и т.\,д., а также анализа полученных результатов. 
Цель реализации данного языка заключалась в создании простого в использовании и расширяемого инструмента, который можно применять для проверки законов больших чисел, моделирования случайных величин, оценки характеристик распределений и других вероятностных экспериментов. 

Интерпретатор ProbabilityScript написан на C++ и выполняет пошаговую интерпретацию сценариев, написанных на этом языке. 
При разработке акцент сделан на ясности архитектуры и корректности реализации основных алгоритмов, таких как генерация случайных чисел и вычисление статистик. 
Несмотря на ориентированность на конкретную область применения, язык спроектирован с возможностью дальнейшего расширения, например, добавления новых типов данных или конструкций управления.

\section{Синтаксис и грамматика}
\label{sec:syntax}

\subsection{Обзор конструкций языка}

Программа на ProbabilityScript состоит из последовательности операторов, выполняемых последовательно. 
Каждый оператор может быть либо простым (например, присваивание или вызов функции), либо составным (например, условная конструкция или цикл). 
Для группировки нескольких операторов в блок используется фигурные скобки \{\}, что позволяет объединять их в единое целое там, где синтаксис требует один оператор (например, тело цикла или условного оператора). 
В языке используются английские ключевые слова и идентификаторы. 
Для разделения операторов применяется либо точка с запятой `;`, либо перевод строки (аналогично многим скриптовым языкам), 
что обеспечивает удобочитаемость кода.

Поддерживаются следующие виды операторов:
\begin{itemize}
    \item \textbf{Присваивание}: сохранение значения выражения в переменную.
    \item \textbf{Условный оператор} \texttt{if}: выполнение блока операторов при выполнении некоторого условия.
    \item \textbf{Цикл повторения} \texttt{repeat}: многократное выполнение блока операторов заданное число раз.
    \item \textbf{Оператор вывода} \texttt{print}: печать значения выражения на экран.
    \item \textbf{Оператор сбора данных} \texttt{collect}: сохранение значения выражения в специальную выборку для последующей статистической обработки.
    \item \textbf{Оператор вывода статистик} \texttt{print\_stat}: вычисление и вывод основных статистических параметров накопленной выборки.
\end{itemize}

Кроме вышеперечисленных, язык поддерживает вызов встроенных функций (например, генераторов случайных чисел), которые могут использоваться в выражениях наравне с переменными и литеральными значениями. 
Каждая функция имеет фиксированную сигнатуру (список ожидаемых аргументов) и возвращает определённое значение (в случае генераторов --- случайное число с заданными параметрами распределения).

\subsection{Выражения и операторы}

Выражения в ProbabilityScript задают правила вычисления числовых значений. 
Поддерживаются стандартные арифметические операции: сложение `+`, вычитание `-`, умножение `*` и деление `/`. 
Также допускается унарный минус для смены знака. 
Приоритет операторов стандартный: сначала выполняются умножение и деление, затем сложение и вычитание (см. таблицу~\ref{tab:precedence}). 
Можно использовать круглые скобки для явного задания порядка вычислений. 

Кроме арифметических операций, выражения могут содержать операции сравнения: равно `==`, не равно `!=`, меньше `<`, больше `>`, меньше или равно `<=`, больше или равно `>=`. 
Результатом сравнения также является вещественное число: 1.0 (истина) или 0.0 (ложь). 
Это позволяет напрямую использовать результаты сравнений в дальнейших вычислениях или условных выражениях. 
Отдельного логического типа в языке не вводится --- логическое значение представляется числом (как в языке Си), причём любое ненулевое числовое значение трактуется как \textit{истина}, а нуль как \textit{ложь}. 
Логические операции (\texttt{\&\&}, \texttt{||}, \texttt{!}) специально не реализованы; при необходимости логическое И и ИЛИ могут быть выражены через арифметические операции (например, $a \text{\texttt{\&\&}} b$ эквивалентно $(a * b) \neq 0$). 

Числовые литералы записываются в десятичном формате (например, \texttt{10}, \texttt{3.14}). 
Идентификаторы (имена переменных и функций) должны начинаться с буквы и могут содержать буквы, цифры и символ подчёркивания, например \texttt{x}, \texttt{sum\_1}. 
Идентификаторы чувствительны к регистру (т.\,е. \texttt{X} и \texttt{x} --- разные имена). 
Следующие слова зарезервированы и не могут использоваться в качестве имён переменных: 
\texttt{if}, \texttt{else}, \texttt{repeat}, \texttt{print}, \texttt{collect}, \texttt{print\_stat}, \texttt{uniform}, \texttt{normal}, \texttt{seed} и др. 

\begin{table}[hbt]
\centering
\caption{Приоритет и ассоциативность операторов ProbabilityScript}
\begin{tabular}{lcl}
\hline
Категория & Операторы & Ассоциативность \\
\hline
Скобки & \texttt{( )} & -- (явно задают порядок) \\
Унарные & \texttt{-} (унарный) & справа налево \\
Множение/деление & \texttt{*}, \texttt{/} & слева направо \\
Сложение/вычитание & \texttt{+}, \texttt{-} & слева направо \\
Сравнения & \texttt{>}, \texttt{<}, \texttt{>=}, \texttt{<=} & не ассоциативны \\
Равенство & \texttt{==}, \texttt{!=} & не ассоциативны \\
\hline
\end{tabular}
\label{tab:precedence}
\end{table}

\subsection{Синтаксис операторов}

Ниже приведена формальная грамматика языка ProbabilityScript в нотации, близкой к EBNF:
\begin{flushleft}
\begin{tabular}{rcl}
\textit{Программа} & ::= & \textit{СписокОператоров} \\ 
\textit{СписокОператоров} & ::= & \textit{Оператор} \{ (``;'' $\mid$ $\backslash$n) \textit{Оператор} \} \\
\textit{Оператор} & ::= & \textit{Присваивание} $\mid$ \textit{If} $\mid$ \textit{Repeat} $\mid$ \textit{Print} $\mid$ \textit{Collect} $\mid$ \textit{PrintStat} \\
\textit{Присваивание} & ::= & \textit{Идентификатор} ``='' \textit{Выражение} \\ 
\textit{If} & ::= & ``if'' ``('' \textit{Выражение} ``)'' \textit{Блок} \\
\textit{Repeat} & ::= & ``repeat'' \textit{Выражение} \textit{Блок} \\
\textit{Print} & ::= & ``print'' \textit{Выражение} \\
\textit{Collect} & ::= & ``collect'' \textit{Выражение} \\
\textit{PrintStat} & ::= & ``print\_stat'' \\ 
\textit{Блок} & ::= & ``{'' \textit{СписокОператоров} ``}'' $\mid$ \textit{Оператор} \\
\textit{Выражение} & ::= & \textit{Выражение} \textit{OpEq} \textit{Выражение} \\
                    & $\mid$ & \textit{Выражение} \textit{OpRel} \textit{Выражение} \\
                    & $\mid$ & \textit{Выражение} \textit{OpAdd} \textit{Выражение} \\
                    & $\mid$ & \textit{Выражение} \textit{OpMul} \textit{Выражение} \\
                    & $\mid$ & \textit{OpUnary} \textit{Выражение} \\
                    & $\mid$ & ``('' \textit{Выражение} ``)'' \\
                    & $\mid$ & \textit{Число} $\mid$ \textit{Идентификатор} $\mid$ \textit{ВызовФункции} \\
\textit{OpEq} & ::= & ``=='' $\mid$ ``!='' \\
\textit{OpRel} & ::= & ``<'' $\mid$ ``>'' $\mid$ ``<='' $\mid$ ``>='' \\
\textit{OpAdd} & ::= & ``+'' $\mid$ ``-'' \\
\textit{OpMul} & ::= & ``*'' $\mid$ ``/'' \\
\textit{OpUnary} & ::= & ``-'' \\
\textit{ВызовФункции} & ::= & \textit{Идентификатор} ``('' [\textit{Аргументы}] ``)'' \\
\textit{Аргументы} & ::= & \textit{Выражение} \{ ``,'' \textit{Выражение} \} \\
\end{tabular}
\end{flushleft}

Как видно из грамматики, присваивание имеет форму \texttt{<идентификатор> = <выражение>}. 
Оператор \texttt{if} требует в скобках условное выражение и исполняет последующий блок, если значение выражения истинно (не равно нулю). 
Блок после \texttt{if} может быть либо одним оператором без фигурных скобок, либо набором операторов в \{~\}. 
Конструкции \texttt{else} в текущей версии языка не предусмотрено: при необходимости её можно имитировать, используя несколько \texttt{if} с противоположными условиями или добавлять расширение в будущем (см. раздел~\ref{sec:conclusion}). 

Цикл \texttt{repeat} выполняет указанный блок операторов определённое число раз. 
После ключевого слова \texttt{repeat} ожидается выражение, вычисляющее число итераций. 
Это выражение округляется до целого (отбрасыванием дробной части) в случае вещественного значения. 
Если результат меньше или равен 0, цикл просто не выполняется ни разу. 
Пример: \texttt{repeat 100 \{ collect X \}} выполнит вложенный блок 100 раз. 

Оператор \texttt{print} вычисляет значение выражения и выводит его (например, на консоль или стандартный поток вывода). 
Оператор \texttt{collect} вычисляет выражение и добавляет полученное значение в специальную коллекцию (выборку) внутри среды выполнения для последующего статистического анализа. 
Наконец, оператор \texttt{print\_stat} инициирует расчёт основных статистических показателей по накопленным данным и их вывод. 
Как правило, \texttt{print\_stat} вызывается после серии операций \texttt{collect}, и выводит такие величины, как объём выборки, среднее значение, дисперсия, среднеквадратическое отклонение и медиана (подробнее в разделе~\ref{sec:stats}). 
\texttt{print\_stat} не требует указания параметров --- он всегда относится ко всей текущей накопленной выборке.

\subsection{Встроенные функции}

ProbabilityScript включает ряд встроенных функций, расширяющих возможности языка. 
Их можно вызывать внутри выражений аналогично математическим функциям. 
Ниже перечислены основные из них с формальной сигнатурой и семантикой:
\begin{itemize}
    \item \texttt{seed(\textit{S})} --- инициализирует генератор случайных чисел заданным целочисленным \textit{seed} (тип аргумента автоматически приводится к целому). Вызывать эту функцию имеет смысл один раз в начале сценария, если требуется воспроизводимость результатов. Возвращаемого значения не имеет (может считаться равным 0).
    \item \texttt{uniform(a, b)} --- возвращает случайное вещественное число, равномерно распределённое в промежутке $[a, b)$. Аргументы $a$ и $b$ задают границы интервала (вещественные). Если $a \ge b$, функция может возвращать всегда $a$ либо генерировать ошибку (пользователю рекомендуется задавать $a < b$ для корректной работы).
    \item \texttt{normal(\textit{mean}, \textit{stddev})} --- возвращает случайное вещественное число, распределённое по нормальному закону с математическим ожиданием \textit{mean} и среднеквадратическим отклонением \textit{stddev}. При \textit{stddev} $\le 0$ генерируется ошибка (дисперсия должна быть положительной). 
\end{itemize}

Перечисленные функции позволяют легко включать в сценарии генерацию случайных данных. 
Например, выражение \texttt{x + uniform(0, 1)} возвращает значение переменной \texttt{x}, увеличенное на случайную величину в диапазоне $[0,1)$. 

\section{Типы данных}
\label{sec:types}

В текущей версии ProbabilityScript имеется единственный тип данных для хранимых и вычисляемых величин --- \textbf{вещественное число двойной точности} (тип \texttt{double} в C++). 
Каждая переменная содержит 64-битное значение с плавающей запятой:contentReference[oaicite:0]{index=0}, что обеспечивает порядка 15~десятичных значащих цифр точности и диапазон значений примерно от $10^{-308}$ до $10^{308}. 

Все числовые литералы в исходном коде интерпретируются как значения типа double. 
Если требуется представлять целочисленные данные, они также хранятся в формате с плавающей запятой (т.\,е. 5 будет представлено как 5.0). 
Арифметические операции выполняются в соответствии с правилами IEEE~754, включая возможное возникновение специальных значений: бесконечностей ($+\infty$, $-\infty$) при переполнении или делении на ноль и NaN (Not a Number) при недопустимых операциях (например, $0/0$). 
Интерпретатор не заменяет поведение стандартной арифметики C++: такие случаи не вызывают исключений, и пользователь должен самостоятельно следить за корректностью получаемых результатов. 

Внутренняя репрезентация вещественных чисел --- формат с порядком и мантиссой, реализуемый аппаратно. 
Это означает, что операции над числами осуществляются быстро, однако имеются ограничения на точность (например, не все десятичные дроби представимы точно в двоичном формате). 
Модель вычислений соответствует принятой в языке C++: используется округление к ближайшему representable значению, возможно накопление погрешности при последовательных операциях. 
Впрочем, для большинства задач моделирования случайных процессов такой точности более чем достаточно.

Отсутствие отдельных типов для целых, логических или строковых данных упрощает язык и реализацию интерпретатора, но накладывает ограничения: 
например, невозможно напрямую работать с текстовыми данными или структурами. 
Тем не менее, единый числовой тип делает язык однородным и предсказуемым: все выражения возвращают число, и все переменные хранят числа. 
В заключительном разделе документации (раздел~\ref{sec:conclusion}) рассмотрены возможности расширения системы типов в будущем.

\section{Лексический анализ}
\label{sec:lexer}

На этапе лексического анализа входной исходный текст программы преобразуется в последовательность токенов (элементарных лексем), удобных для последующего синтаксического анализа. 
Лексический анализатор (сканер) проходит по исходному коду символ за символом и распознаёт токены согласно заданным правилам.

Основные виды токенов в ProbabilityScript:
\begin{itemize}
    \item \textbf{Идентификаторы}: последовательности букв, цифр и символа ``\_'' (подчёркивания), не начинающиеся с цифры. Примеры: \texttt{x}, \texttt{X2}, \texttt{sample\_mean}. Используются для обозначения переменных и имён функций. 
    \item \textbf{Ключевые слова}: зарезервированные идентификаторы, обозначающие конструкции языка: \texttt{if}, \texttt{else}, \texttt{repeat}, \texttt{print}, \texttt{collect}, \texttt{print\_stat}, \texttt{uniform}, \texttt{normal}, \texttt{seed} и т.\,д. Они распознаются так же, как идентификаторы, но на этапе лексического анализа отмечаются особым типом токена и не требуют создания переменной.
    \item \textbf{Числовые литералы}: десятичные числа, возможно содержащие точку (для дробной части). Пример: \texttt{12}, \texttt{3.14}, \texttt{0.5}. Экспоненциальная нотация (например, \texttt{1e-3}) может не поддерживаться (в текущей реализации упор сделан на простоту). Литерал обрабатывается как значение типа double.
    \item \textbf{Операторы и разделители}: символы, имеющие специальное значение в синтаксисе, включая \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{==}, \texttt{!=}, \texttt{>}, \texttt{<}, \texttt{>=}, \texttt{<=}, \texttt{=}, \texttt{(}, \texttt{)}, \texttt{\{}, \texttt{\}}, \texttt{,}, \texttt{;}.
    \item \textbf{Прочие токены}: пробельные символы (пробел, табуляция, перевод строки) и комментарии игнорируются сканером. В данной версии языка комментарии как таковые не определены, поэтому любой текст после символа \# или // не распознаётся специально и приведёт к лексической ошибке, если не является частью синтаксиса.
\end{itemize}

Лексер реализован по принципу \textit{детерминированного конечного автомата} (ДКА). 
При чтении исходного текста он находится в некотором состоянии (например, начальном, в котором не накоплено ничего) и в зависимости от текущего символа либо переходит в новое состояние, либо завершает распознавание текущего токена. 
Например, упрощённо:
\begin{itemize}
    \item При встрече буквы в начальном состоянии сканер переходит в состояние ``чтение идентификатора'' и будет считывать последующие буквы/цифры.
    \item При встрече цифры в начальном состоянии сканер переходит в состояние ``чтение числа'' и считывает последовательность цифр, при встрече точки --- остаётся в том же состоянии (для дробной части).
    \item Пробельные символы в начальном состоянии игнорируются (пропускаются) и не приводят к созданию токена.
    \item Специальные символы (например, \texttt{+}, \texttt{-}) мгновенно распознаются как отдельные токены (при этом \texttt{-} требует проверки, не является ли он частью числа или унарным оператором --- обычно в лексере \texttt{-} всегда токен оператора, а унарный минус различается потом на этапе синтаксического анализа).
    \item Составные операторы из двух символов (например, \texttt{==}, \texttt{<=}) распознаются путем проверки сразу после первого символа: лексер заглядывает на следующий символ и при совпадении объединяет их в один токен.
\end{itemize}

Алгоритм работы лексера можно описать следующим псевдокодом:
\begin{verbatim}
while (не конец входа) {
    ch = next_char();
    if (ch является пробелом или управляющим символом новой строки) {
        continue; // пропустить 
    } else if (буква(ch)) {
        lexeme = ch;
        while (букваИлиЦифра(peek_char())) {
            lexeme += next_char();
        }
        if (lexeme является ключевым словом) {
            emit_token(TOKEN_KEYWORD, lexeme);
        } else {
            emit_token(TOKEN_IDENTIFIER, lexeme);
        }
    } else if (цифра(ch)) {
        lexeme = ch;
        has_dot = false;
        while (цифра(peek_char()) || (peek_char() == '.' && !has_dot)) {
            next = next_char();
            if (next == '.') has_dot = true;
            lexeme += next;
        }
        emit_token(TOKEN_NUMBER, lexeme);
    } else {
        switch (ch) {
            case '+': emit_token(TOKEN_PLUS, "+"); break;
            case '-': 
                if (цифра(peek_char())) {
                    // особый случай: литерал с ведущим минусом как отдельный токен '-' + число
                    emit_token(TOKEN_MINUS, "-"); 
                    continue;
                } else {
                    emit_token(TOKEN_MINUS, "-"); break;
                }
            case '=': 
                if (peek_char() == '=') { next_char(); emit_token(TOKEN_EQ, "=="); }
                else emit_token(TOKEN_ASSIGN, "=");
                break;
            case '!':
                if (peek_char() == '=') { next_char(); emit_token(TOKEN_NEQ, "!="); }
                else throw LexError("неожиданный символ '!'");
                break;
            // ... другие односимвольные токены
            default:
                throw LexError("неизвестный символ");
        }
    }
}
\end{verbatim}

В приведённом фрагменте \texttt{emit\_token(TYPE, text)} означает создание токена определённого типа с указанным текстовым значением, \texttt{peek\_char()} --- просмотр следующего символа без потребления. 
Реальная реализация может отличаться, но суть остаётся той же: мы идентифицируем классы символов и на основе этого принимаем решения о формировании токенов.

Если лексер встречает последовательность символов, не подпадающих ни под одно правило (например, \texttt{\$} или кириллические буквы вне строкового литерала), он генерирует лексическую ошибку. 
Сообщение об ошибке обычно содержит номер строки/позиции и описание проблемы (``неизвестный символ''). 
На лексическом уровне также выявляются слишком большие числовые литералы (при превышении диапазона double, однако библиотека C++ сама преобразует их в \texttt{inf}) и другие простые ошибки.

\section{Синтаксический анализ}
\label{sec:parser}

Синтаксический анализатор (парсер) отвечает за разбор последовательности токенов согласно грамматике языка и построение абстрактного синтаксического дерева (AST). 
В данном проекте реализован \textbf{рекурсивный спуск} --- простой и наглядный метод парсинга, подходящий для относительно простой грамматики ProbabilityScript. 
Каждое правило грамматики соответствует функции парсера: например, функция \texttt{parseExpression()} разбирает нетерминал \textit{Выражение}, а \texttt{parseStatement()} --- \textit{Оператор}. 
Парсер последовательно вызывает эти функции по мере необходимости, обходя древовидно структуру грамматики. 

Ниже, для иллюстрации, приведена структура основных узлов AST и соответствующих им конструкций языка:
\begin{itemize}
    \item \textbf{Expr} --- абстрактный класс (интерфейс) для всех узлов, представляющих выражения. Имеет потомков:
    \begin{itemize}
        \item \textbf{NumberExpr} (литеральное число) --- хранит значение типа double.
        \item \textbf{VariableExpr} (идентификатор переменной) --- хранит имя переменной.
        \item \textbf{BinaryExpr} (бинарная операция) --- содержит указатели на левое и правое подвыражения и тип операции (например, \texttt{+}, \texttt{<}, \texttt{==}).
        \item \textbf{UnaryExpr} (унарная операция) --- содержит подвыражение и тип (например, унарный минус).
        \item \textbf{CallExpr} (вызов функции) --- хранит имя вызываемой функции и список узлов-аргументов (выражений).
    \end{itemize}
    \item \textbf{Stmt} --- абстрактный класс для узлов-операторов (statements). Основные подклассы:
    \begin{itemize}
        \item \textbf{AssignStmt} (присваивание) --- хранит имя переменной и выражение-значение.
        \item \textbf{IfStmt} (условный оператор) --- содержит выражение-условие и узел-блок (или одиночный оператор), исполняемый при истинности условия.
        \item \textbf{RepeatStmt} (цикл) --- содержит выражение-счётчик итераций и узел-блок, который нужно повторно выполнять.
        \item \textbf{PrintStmt} (вывод) --- содержит выражение, значение которого требуется вывести.
        \item \textbf{CollectStmt} (сбор данных) --- содержит выражение, значение которого нужно добавить в выборку.
        \item \textbf{PrintStatStmt} (вывод статистики) --- не хранит дополнительных данных (оперирует глобальной выборкой среды выполнения).
        \item \textbf{BlockStmt} (блок кода) --- содержит список дочерних узлов-операторов, представляющих операторы внутри фигурных скобок.
    \end{itemize}
\end{itemize}

Парсер строит AST, последовательно создавая объекты вышеперечисленных классов. Например, при разборе присваивания \texttt{x = uniform(0, 1)} будет создан узел AssignStmt с именем ``x'' и дочерним узлом-выражением CallExpr для вызова \texttt{uniform} с двумя узлами NumberExpr в качестве аргументов.

Для управления порядком операций парсер учитывает приоритеты. Реализация рекурсивного спуска обычно разделяет разбор выражений по уровням приоритета: 
например, \texttt{parseTerm()} для считывания факторов умножения/деления, \texttt{parseFactor()} для базовых элементов (число, скобки, вызов функции). 
При разборе бинарных операций применяется принцип левоассоциативности: 
после разбора левого операнда и оператора парсер рекурсивно разбирает правый операнд и при необходимости продолжает чтение последующих операций того же уровня.

Если на входе обнаруживается последовательность, не соответствующая грамматике, парсер генерирует \textbf{синтаксическую ошибку}. 
Например, отсутствие закрывающей скобки или ключевого слова там, где оно ожидается, вызовет выброс исключения с сообщением об ошибке (обычно указываются текущий неразобранный токен и ожидания парсера). 
После возникновения синтаксической ошибки интерпретация сценария прерывается.

Построение AST является критически важной фазой, поскольку именно на основе дерева будет осуществляться выполнение программы на следующем этапе. 
AST устраняет неоднозначности исходного текста (например, жёстко фиксирует порядок вычислений в соответствии с приоритетами) и предоставляет удобную структуру данных для интерпретатора.

\section{Выполнение программы (интерпретация)}
\label{sec:execution}

Интерпретатор ProbabilityScript выполняет код, обходя построенное синтаксическое дерево и производя вычисления согласно семантике языка. 
Модель исполнения основана на \textbf{обходе AST} (вычислительном дереве): для каждого узла вычисляются (или выполняются) его подузлы, после чего применяется операция, соответствующая данному узлу.

\subsection{Вычисление выражений}

Выражения вычисляются в соответствии с ожидаемой семантикой математических операций:
\begin{itemize}
    \item \textbf{Литерал (NumberExpr)}: непосредственное значение возвращается как результат.
    \item \textbf{Переменная (VariableExpr)}: интерпретатор обращается к среде выполнения, чтобы получить текущее значение переменной с данным именем. Если переменная не была ранее присвоена, генерируется ошибка времени выполнения (использование неинициализированной переменной).
    \item \textbf{Бинарная операция (BinaryExpr)}: сначала вычисляются левое и правое подвыражения (рекурсивный обход поддеревьев), затем к полученным значениям применяется операция. Арифметические операции (+, -, *, /) возвращают числовой результат. Операции сравнения (>, <, >=, <=, ==, !=) возвращают 1.0, если условие истинно, или 0.0, если ложно. Деление на ноль на уровне интерпретатора не перехватывается специально --- при попытке вычислить $x/0$ будет получено значение \texttt{inf} или \texttt{NaN} в соответствии с IEEE~754.
    \item \textbf{Унарная операция (UnaryExpr)}: вычисляет подвыражение и, например, меняет знак (для унарного минуса) у полученного значения.
    \item \textbf{Вызов функции (CallExpr)}: интерпретатор вычисляет все выражения-аргументы (слева направо), затем выполняет предопределенную функцию с этими аргументами и возвращает полученный результат. Например, \texttt{uniform(0,1)} при вызове генерирует случайное число и возвращает его.
\end{itemize}

При вычислении выражений стоит отметить модель истинности: \textbf{любое ненулевое число трактуется как истина}. 
Это проявляется, например, при вычислении условного выражения \texttt{if} --- результат выражения проверяется на неравенство нулю. 
В то же время, выражения сравнения сами возвращают 0 или 1, так что вложенные сравнения работают интуитивно ожидаемо.

\subsection{Выполнение операторов}

Интерпретатор обрабатывает операторы верхнего уровня программы последовательно, обновляя при необходимости состояние (содержимое переменных, накопленные данные выборки и пр.):
\begin{itemize}
    \item \textbf{Присваивание (AssignStmt)}: вычисляется выражение значения, затем полученное число сохраняется в среде выполнения под заданным именем переменной. Если такой переменной ещё не было, она создаётся; иначе её старое значение заменяется новым.
    \item \textbf{Условный оператор (IfStmt)}: вычисляется выражение-условие; если результат отличен от 0 (истина), интерпретатор выполняет вложенный оператор или блок. Если результат равен 0 (ложь), вложенный блок пропускается. (Напомним, ветка \texttt{else} не реализована в текущей версии, поэтому при ложном условии просто ничего не происходит.)
    \item \textbf{Цикл (RepeatStmt)}: вычисляется выражение-счётчик. Из него извлекается целочисленное значение (например, приводится через \texttt{int} путём отбрасывания дробной части). Пусть результат равен $N$. Если $N \le 0$, цикл не выполняется. Если $N > 0$, интерпретатор повторно (в цикле \texttt{for} или аналогично) выполняет вложенный блок $N$ раз. Каждая итерация цикла может изменять переменные, вызывать функции, собирать данные и т.\,д. как обычный последовательный код.
    \item \textbf{Вывод (PrintStmt)}: вычисляется вложенное выражение; затем его значение выводится пользователю. Конкретная реализация может выводить число в стандартный поток вывода (консоль) с определённой форматированием (например, фиксированного или экспоненциального вида). После вывода, выполнение продолжается.
    \item \textbf{Сбор данных (CollectStmt)}: вычисляет выражение и добавляет его результат в текущую выборку (массив) внутри среды выполнения. Этот оператор не производит видимого эффекта сразу, но влияет на последующий результат \texttt{print\_stat}. Обычно \texttt{collect} вызывается внутри цикла, чтобы накопить серию наблюдений случайной величины.
    \item \textbf{Вывод статистики (PrintStatStmt)}: при выполнении этого оператора интерпретатор обращается к среде выполнения для вычисления статистических параметров по накопленной выборке. Рассчитываются, как минимум, объём выборки (количество собранных значений), выборочное среднее, выборочная дисперсия, среднеквадратическое отклонение и медиана. Затем эти показатели выводятся на экран в читаемом формате, после чего (по реализации) выборка может быть очищена (либо сохраняться для последующих вычислений, если не очищать). Поведение реализации: как правило, после \texttt{print\_stat} выборка сбрасывается, чтобы следующая серия \texttt{collect} начала новый эксперимент.
\end{itemize}

В процессе интерпретации состояние программы хранится и изменяется в структуре \textbf{среды выполнения} (о ней в следующем разделе). 
Интерпретатор не выполняет никаких оптимизаций кода во время исполнения (таких как пропуск повторных вычислений) --- каждый оператор обрабатывается явно. 
Это упрощает поведение и улучшает предсказуемость (в ущерб скорости при очень больших объёмах данных, что, однако, не критично для учебных задач).

Следует отметить, что \textbf{ложные} (нулевые) условия и пустые циклы просто приводят к тому, что вложенные операторы пропускаются, без ошибок. 
Однако некоторые ошибки (например, деление на ноль, выход за диапазон) неявно обработаются как особые числовые значения, о чём было сказано выше. 

\section{Среда выполнения}
\label{sec:runtime}

Среда выполнения (\textit{runtime environment}) представляет собой совокупность структур данных, хранящих состояние интерпретируемой программы во время её выполнения. В данной реализации среда включает:
\begin{itemize}
    \item Таблицу переменных и их значений.
    \item Структуру для хранения собранных значений (выборки) при вызове \texttt{collect}.
    \item Генератор случайных чисел (и его параметры, например, текущее зерно генерации).
\end{itemize}

\subsection{Хранение переменных}

Переменные сохраняются в динамической структуре (например, \texttt{std::unordered\_map<string, double>} или аналогичном словаре), сопоставляющей именам (ключам) числовые значения. 
При выполнении оператора присваивания, если имя отсутствует в таблице, создаётся новая запись; если присутствует, её значение обновляется. 
Все переменные глобальные (в текущей версии нет вложенных областей видимости или локальных переменных функций). 
Область видимости переменных --- весь сценарий после их первого определения.

Доступ к переменной (\texttt{VariableExpr}) осуществляется путём поиска имени в таблице. Это операция $O(\log n)$ или $O(1)$ в среднем (в зависимости от реализации контейнера). 
Если имя не найдено, интерпретатор генерирует ошибку (с информацией о некорректном имени переменной). 
Переменные не типизированы явно, хранят всегда вещественные числа. 
Память под них выделяется по мере добавления записей; освобождение (в текущей реализации) происходит только по завершении программы (или при явном удалении, что не предусмотрено на уровне языка).

\subsection{Механизм \texttt{collect} и накопление выборки}

При каждом выполнении оператора \texttt{collect} вычисленное значение добавляется в специальную коллекцию, представляющую собой список (или динамический массив) чисел. 
В реализации используется, например, \texttt{std::vector<double>} или собственная структура последовательности. 
Изначально, до начала сбора данных, коллекция пуста. 
Каждый вызов \texttt{collect} делает \texttt{collection.push\_back(value)}. 
Таким образом накапливается выборка значений, которую можно рассматривать как результаты повторных наблюдений некоторой случайной величины. 

Оператор \texttt{print\_stat} обращается к этой коллекции для вычисления статистик. 
После вывода статистики, по замыслу, выборка может быть очищена (например, \texttt{collection.clear()}) для начала новой серии сбора, хотя это зависит от реализации. 
В нашем интерпретаторе после \texttt{print\_stat} коллекция действительно очищается, чтобы избежать повторного включения прошлых данных в новые расчёты.

Предусмотрена возможность собирать большие объёмы данных; стандартные контейнеры способны динамически расширяться при добавлении элементов. 
Ограничением является лишь объём памяти.

\subsection{Генерация случайных чисел}

Для реализации функций \texttt{uniform} и \texttt{normal} используется генератор псевдослучайных чисел. 
В среде выполнения хранится текущее \textbf{seed} (зерно генерации) и генератор (например, \texttt{std::mt19937} или вызовы \texttt{rand()} из <cstdlib>). 
Функция \texttt{seed(s)} задаёт начальное значение генератора: в случае использования \texttt{rand()} вызывается \texttt{srand(s)}, а при использовании <random> - инициализируется объект генератора заданным seed.

Для равномерного распределения \texttt{uniform(a, b)} берётся либо стандартная функция \texttt{rand()}, нормированная на $[0,1)$ (с последующим масштабированием $a + (b-a)*U(0,1)$), либо генератор \texttt{std::uniform\_real\_distribution} из библиотеки <random>. 
Результат приводится к double и возвращается. 

Для нормального распределения \texttt{normal(mean, stddev)} возможны разные методы. В данной реализации использован метод Бокса–Мюллера: генерируются две независимые равномерные величины $U_1, U_2$ на $[0,1)$, затем вычисляется $Z = \sqrt{-2 \ln U_1} \cos(2\pi U_2)$, имеющее стандартное нормальное распределение. Результат масштабируется: $X = \textit{mean} + Z \cdot \textit{stddev}$ и возвращается пользователю. 
При каждом вызове \texttt{normal} происходит вычисление нового независимого случайного значения.

Важно отметить, что при фиксированном \texttt{seed} последовательность возвращаемых псевдослучайных чисел детерминирована (что полезно для воспроизводимости результатов), а при разном \texttt{seed} или если \texttt{seed} не вызывать вовсе (часто генератор инициализируют текущим временем), последовательности будут различаться.

Точность и распределение генератора соответствуют используемым библиотечным функциям. 
Например, \texttt{rand()} обычно генерирует 31-битные числа, что может не давать идеальной статистической равномерности, но для учебных целей приемлемо. 
При необходимости генератор можно заменить на более качественный без изменения логики интерпретатора.

\section{Статистический модуль}
\label{sec:stats}

Одной из ключевых возможностей ProbabilityScript является автоматическое вычисление статистических характеристик по собранным данным. 
После выполнения серии операторов \texttt{collect} можно вызвать \texttt{print\_stat}, чтобы получить сводку по выборке. 
Реализованы следующие статистики:
\begin{itemize}
    \item \textbf{count} (объём выборки $N$): общее количество значений, добавленных в выборку на момент вызова \texttt{print\_stat}. 
    \item \textbf{mean} (выборочное среднее $\bar{x}$): $\displaystyle \bar{x} = \frac{1}{N}\sum_{i=1}^{N} x_i$. Вычисляется суммированием всех значений и делением на $N$.
    \item \textbf{var} (выборочная дисперсия $s^2$): мера разброса значений, вычисляемая по формуле $\displaystyle s^2 = \frac{1}{N}\sum_{i=1}^{N} (x_i - \bar{x})^2$. В реализации для эффективности может использоваться эквивалентная формула $s^2 = \frac{1}{N}\sum x_i^2 - \bar{x}^2$, но она менее численно устойчива. Для повышения устойчивости при больших $N$ можно применять алгоритм на основе первичных и вторичных моментов или метод Вельфорда.
    \item \textbf{stddev} (среднеквадратическое отклонение $\sigma$): квадратный корень из дисперсии, $\sigma = \sqrt{s^2}$. Показывает среднее отклонение значений от среднего.
    \item \textbf{median} (медиана): величина, отделяющая верхнюю половину выборки от нижней. Вычисляется следующим образом: выборка сортируется, и если $N$ нечётно, медиана равна среднему элементу, если $N$ чётно, медиана берётся как полусумма двух средних значений:contentReference[oaicite:2]{index=2}. Формально: при чётном $N$ $\displaystyle \text{median} = \frac{x_{(N/2)} + x_{(N/2+1)}}{2}$, при нечётном --- $x_{((N+1)/2)}$ (где $x_{(k)}$ --- $k$-й элемент упорядоченного по возрастанию набора):contentReference[oaicite:3]{index=3}.
\end{itemize}

Алгоритмы вычисления этих характеристик следующие:
\begin{itemize}
    \item \textbf{Объём выборки} подсчитывается при добавлении (можно хранить счётчик и просто выводить его значение).
    \item \textbf{Сумма} $\sum x_i$ и \textbf{сумма квадратов} $\sum x_i^2$ могут накапливаться на лету при каждом \texttt{collect}. Тогда среднее и дисперсия могут быть вычислены в \texttt{print\_stat} в $O(1)$. Наш интерпретатор, однако, для простоты вычисляет обе суммы в момент вывода, проходя один раз по массиву значений (сложность $O(N)$).
    \item \textbf{Среднее} $\bar{x}$ получаеться делением суммы на $N$.
    \item \textbf{Дисперсия} $s^2$ вычисляется по определению или альтернативной формуле. Важным моментом является численная стабильность: прямой подсчёт $\frac{\sum x_i^2}{N} - \bar{x}^2$ может привести к потере значимых цифр при вычитании близких величин. Для уменьшения ошибки предпочтительно использовать двупроходный алгоритм (сначала находить $\bar{x}$, затем суммировать квадраты отклонений) или алгоритм Вельфорда. В этом проекте, учитывая умеренные объёмы данных, был реализован двупроходный подход: после получения $\bar{x}$ выполняется второй цикл для вычисления $\sum (x_i - \bar{x})^2$.
    \item \textbf{Медиана} вычисляется сортировкой копии выборки и выбором центрального элемента (или двух) как описано выше. Время работы сортировки $O(N \log N)$, что для целей данного языка (как правило, $N$ не слишком велико) вполне допустимо.
\end{itemize}

Численная устойчивость вычисления средней и дисперсии обеспечивается выбором алгоритма. Для большинства практических случаев точности double достаточно, однако при $N$ в сотни тысяч может проявляться накопление ошибки. Использование улучшенных алгоритмов (например, метод Кэхэна для суммирования) могло бы улучшить точность суммирования, но в текущей реализации это не критично.

Результаты статистических вычислений выводятся обычно с определённым форматированием (например, фиксированное число знаков после запятой). 
Пример вывода: 
\begin{verbatim}
Count = 1000
Mean = 0.5021
Variance = 0.0813
Std.Dev = 0.2851
Median = 0.5006
\end{verbatim}
В данном примере показаны названия статистик и их значения. 
Такие результаты позволяют пользователю быстро оценить характеристики распределения случайной величины, данные для которой он собрал с помощью \texttt{collect}.

\section{Обработка ошибок}
\label{sec:errors}

Интерпретатор ProbabilityScript различает несколько типов ошибок:
\begin{itemize}
    \item \textbf{Лексические ошибки}: обнаруживаются на этапе лексического анализа, когда входной текст содержит недопустимые символы или последовательности. Например, встреча неизвестного символа (не буквы, не цифры и не поддерживаемого знака пунктуации) вызовет ошибку. Также сюда можно отнести чрезмерно длинные идентификаторы (если бы накладывались ограничения на длину) или некорректный формат числового литерала (например, \texttt{..5}).
    \item \textbf{Синтаксические ошибки}: возникают на этапе разбора, когда последовательность токенов не может быть применена к грамматике языка. Примеры: отсутствует закрывающая скобка \texttt{)}, лишняя фигурная скобка, неожиданное ключевое слово, неправильный порядок токенов (например, \texttt{= x 5} вместо \texttt{x = 5}). При синтаксической ошибке парсер обычно генерирует исключение \texttt{ParseException} с сообщением, указывающим текущий токен и ожидаемые варианты.
    \item \textbf{Ошибки времени выполнения}: выявляются в процессе исполнения программы. Сюда относятся:
    \begin{itemize}
        \item Обращение к неопределённой переменной (отсутствует в таблице символов).
        \item Деление на ноль в явном виде (хотя, как упоминалось, на уровне double это не приводит к исключению, но может рассматриваться как логическая ошибка).
        \item Недопустимые аргументы функций: например, \texttt{normal(0, -5)} (отрицательное стандартное отклонение), \texttt{uniform(5, 1)} (левая граница больше правой --- в текущей реализации это не вызывает исключения, но приводит к некорректному смыслу).
        \item Вызов \texttt{print\_stat} при пустой выборке. В такой ситуации интерпретатор выдаёт сообщение об ошибке (недостаточно данных для статистики) и останавливает выполнение.
    \end{itemize}
    \item \textbf{Логические ошибки}: это ошибки в логике программы пользователя, которые интерпретатор не может автоматически обнаружить. Например, неправильно заданная формула, лишний или пропущенный вызов \texttt{collect}, неверная интерпретация результатов. Эти ошибки не генерируют исключений, но приводят к неправильным результатам. Ответственность за их устранение лежит на пользователе.
\end{itemize}

При обнаружении ошибки интерпретатор формирует диагностическое сообщение. В сообщении указывается тип ошибки (лексическая, синтаксическая или выполнения) и описание проблемы. Для синтаксических и лексических ошибок обычно сообщается номер строки и позиция в строке, где обнаружена ошибка, чтобы упростить отладку сценария. Например: \texttt{Syntax error: unexpected token `\}' at line 5, col 3}. 

После выдачи сообщения выполнение программы прекращается. Интерпретатор не пытается продолжать исполнение после ошибки, так как состояние программы может быть некорректным. Исключение составляют лишь некоторые нефатальные ситуации, трактуемые как предупреждения (в текущей версии таких нет, но гипотетически можно игнорировать повторную инициализацию seed и т.\,п.).

Стоит отметить, что большинство ошибок выявляется на ранних этапах (лексика и синтаксис). Если исходный код успешно проходит парсинг, то далее остаётся небольшой набор возможных ошибок выполнения, перечисленных выше. Логические же ошибки находятся вне контроля интерпретатора, и отладка таких ошибок сводится к анализу получаемых результатов и сопоставлению их с ожидаемыми.

\section{Архитектура реализации}
\label{sec:architecture}

Весь проект интерпретатора ProbabilityScript состоит из нескольких модулей, отражающих основные этапы обработки кода:
\begin{itemize}
    \item \textbf{Лексер} (\texttt{lexer.cpp}) --- содержит функции и структуры для чтения исходного текста и генерации токенов. Определяет типы токенов (например, перечисление \texttt{TokenType} с вариантами: IDENTIFIER, NUMBER, KEYWORD\_IF, OPERATOR\_PLUS, и т.\,д.) и структуру токена (тип + значение + позиция). Лексер обеспечивает метод \texttt{getNextToken()}, возвращающий следующий токен при каждом вызове.
    \item \textbf{Парсер} (\texttt{parser.cpp}) --- реализует функции рекурсивного спуска, описанные в предыдущем разделе. Он использует лексер для получения токенов (либо через явные вызовы \texttt{getNextToken()}, либо на основе текущего ``глядывания'' \texttt{currentToken}). В случае обнаружения синтаксической ошибки парсер возбуждает исключение \texttt{ParseException}.
    \item \textbf{AST} (\texttt{ast.h}, \texttt{ast.cpp}) --- содержит определения классов узлов синтаксического дерева, таких как Expr и Stmt, и их наследников. Каждый класс имеет поля для хранения необходимых данных (например, у BinaryExpr --- \texttt{op}, \texttt{left}, \texttt{right}), а также может определять виртуальный метод \texttt{execute()} или \texttt{evaluate()} для выполнения (в некоторых реализациях интерпретатора код выполнения можно включить прямо внутрь узлов AST).
    \item \textbf{Интерпретатор} (\texttt{interpreter.cpp}) --- основной модуль, который либо рекурсивно обходит AST, либо содержит реализацию visitor-паттерна для применения операций. В нашем случае, например, реализована функция \texttt{executeStatement(Stmt* stmt)}, которая по типу оператора вызывает соответствующую обработку, и \texttt{evaluateExpression(Expr* expr)} для вычисления выражений. Интерпретатор управляет средой выполнения: читает и записывает переменные, управляет коллекцией собранных значений, вызывает генератор случайных чисел.
    \item \textbf{Среда выполнения} (\texttt{environment.h}) --- включает структуры для хранения переменных и выборки, а также функции-утилиты: например, \texttt{addSample(double x)} (добавить значение в выборку), \texttt{clearSamples()} (очистить выборку), \texttt{getMean()} (вычислить среднее), \texttt{getVariance()}, \texttt{getMedian()} и т.\,д. Этот модуль инкапсулирует логику статистических вычислений, позволяя интерпретатору просто вызывать \texttt{env.printStats()} для вывода результатов.
    \item \textbf{Модуль матриц} (\texttt{Matrix\_MAS.h}, \texttt{Matrix.cpp}) --- реализует класс \texttt{Matrix<T>} для математических операций над матрицами, включая алгоритмы решения СЛАУ, обратной матрицы и подсчёта нормы и числа обусловленности. Этот модуль не напрямую используется интерпретатором для исполнения скриптов (так как язык пока не поддерживает переменные-матрицы), однако он был разработан в рамках проекта и может быть интегрирован при расширении языка (см. \S\ref{sec:algorithms}). Например, можно представить, что в будущей версии появится тип \texttt{matrix} и функции для работы с ним, тогда реализованные алгоритмы будут кстати.
\end{itemize}

Структура кода разбивает ответственность по классическим фронтам компилятора/интерпретатора: лексический анализ, синтаксический анализ, выполнение. 
Такое разделение облегчает отладку и развитие проекта. 
Например, можно модифицировать или улучшать алгоритм лексера, не затрагивая парсер или интерпретатор. 
Добавление новых встроенных функций чаще всего требует правок только в интерпретаторе (добавить обработку нового имени в \texttt{CallExpr} или как отдельный случай в eval). 
Добавление новых синтаксических конструкций скажется на парсере и потребует новых классов AST, но ядро интерпретации остаётся прежним.

Язык С++ выбран для реализации благодаря эффективности и богатой стандартной библиотеке (включая \texttt{<random>} для генерации чисел, \texttt{<algorithm>} для сортировки при вычислении медианы и т.\,п.). 
Классы и функции разделены по файлам, как указано выше, для удобства сопровождения.

Наконец, модуль \textbf{тестирования} (\texttt{Tests.h}, \texttt{main.cpp}) содержит набор функций, проверяющих корректность основных компонентов: динамических массивов, списков, матричных алгоритмов и др. 
В функции \texttt{main} проекта вызываются \texttt{TestDynamicArray()}, \texttt{TestMatrixIdentity()} и подобные, чтобы убедиться в правильности низкоуровневых частей. 
После успешного прохождения тестов интерпретатор может быть использован для запуска пользовательских скриптов (в рамках данного задания, возможно, интерактивный ввод или чтение файла не реализованы, но могли бы быть добавлены).

\section{Заключение}
\label{sec:conclusion}

В данной документации представлен полный обзор языка сценариев ProbabilityScript, его семантики, а также внутренних деталей реализации интерпретатора. 
Разработанный язык уже предоставляет базовый набор возможностей для моделирования случайных процессов и сбора статистики, однако существует ряд направлений для расширения и улучшения:
\begin{itemize}
    \item \textbf{Расширение синтаксиса}: Добавление ветви \texttt{else} к условному оператору \texttt{if} позволило бы обрабатывать альтернативный случай в тех же конструкциях. Также можно ввести циклы типа \texttt{while} (с условием, проверяемым перед каждой итерацией) или \texttt{for} (с счётчиком), что повысит выразительность языка.
    \item \textbf{Новые типы данных}: Введение целочисленного типа (например, \texttt{int}) могло бы повысить эффективность и корректность в тех случаях, когда требуется работать с целыми (например, подсчёт). Отдельный логический тип (\texttt{bool}) позволил бы явно выражать условия. В перспективе можно добавить и тип \texttt{matrix} для работы с матрицами непосредственно из сценария, используя уже реализованные алгоритмы (обратная матрица, решение СЛАУ и пр.).
    \item \textbf{Больше встроенных функций}: Например, генерация случайных чисел по другим законам распределения (экспоненциальному, биномиальному и т.\,д.), дополнительные математические функции (тригонометрические, логарифмы). Статистический модуль можно расширить расчетом доверительных интервалов, квантилей, тестов на распределение.
    \item \textbf{Улучшение производительности}: Текущая интерпретация работает в однопоточном режиме. Можно рассмотреть возможность распараллеливания циклов \texttt{repeat} при очень больших $N$ (если каждый цикл независим). Кроме того, можно реализовать компиляцию сценария в байт-код или машинный код (JIT-компиляция), что ускорило бы выполнение при многократных запусках одних и тех же расчётов.
    \item \textbf{Интеграция с внешними системами}: Добавление возможностей ввода/вывода из файлов, графического отображения гистограмм собранных данных или взаимодействия с языками типа Python/Matlab для более широкого применения.
    \item \textbf{Обработка ошибок}: Развитие системы сообщений об ошибках, добавление предупреждений (например, предупреждать о вызове \texttt{print\_stat} на пустой выборке, вместо немедленного прекращения исполнения).
\end{itemize}

В своём текущем состоянии ProbabilityScript успешно справляется с задачами, для которых он создавался: 
позволяет с минимальным кодом выполнить серии испытаний, собрать статистику и вывести ключевые характеристики. 
Он демонстрирует концепцию создания специализированного языка для ограниченной предметной области (Domain-Specific Language) и может служить основой для дальнейших экспериментов студентов и разработчиков. 

Опираясь на описанную архитектуру, дальнейшее развитие языка может происходить инкрементально. Например, добавление нового оператора потребует:
\begin{enumerate}
    \item Изменить грамматику парсера (добавить новый кейс в \texttt{parseStatement}).
    \item Создать новый класс узла AST (если необходимо).
    \item Дополнить функцию интерпретации (например, метод \texttt{executeStatement}) для обработки нового узла.
    \item (Опционально) Скорректировать лексер, если вводится новое ключевое слово или символ.
\end{enumerate}
Благодаря модульности системы, такие изменения локальны.

Подводя итог, проект ProbabilityScript продемонстрировал полный цикл разработки от формального определения языка до его программной реализации. 
Техническая документация, представленная выше, даёт целостное представление о принципах работы интерпретатора и может служить руководством для разработчиков, желающих разобраться или усовершенствовать данный язык.

\end{document}