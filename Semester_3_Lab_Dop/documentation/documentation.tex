\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{caption}
\captionsetup[lstlisting]{labelfont=bf, labelsep=period} % Make listing captions bold "Listing."
\usepackage{amsmath, amssymb}

\begin{document}

% Титульный лист
\begin{titlepage}
\begin{center}
\large{\textbf{НИЯУ МИФИ}}\\
\large{\textbf{Кафедра 22 «Кибернетики»}}\\[5cm]

\textbf{\Large Лабораторная работа}\\[0.2cm]
\textbf{\large на тему: «Разработка компактного языка для вероятностного моделирования»}\\
\textbf{\large (язык сценариев ProbabilityScript)}\\[5cm]

\begin{flushright}
Выполнил: \underline{\hspace{5cm}} (ФИО студента)\\[0.3cm]
Руководитель: \underline{\hspace{5cm}} (ФИО преподавателя)\\
\end{flushright}

\vfill
Москва -- 2025

\end{center}
\end{titlepage}

\section*{Введение}
\addcontentsline{toc}{section}{Введение} % Добавляем введение в оглавление, если понадобится
Цель проекта -- разработка компактного предметно-ориентированного языка \textbf{ProbabilityScript} для вероятностного моделирования. Этот язык сценариев предназначен для упрощения моделирования случайных процессов и статистических вычислений. В рамках проекта реализован интерпретатор, позволяющий задавать последовательность случайных экспериментов, собирать результаты и рассчитывать основные статистические показатели. 

Представленная документация описывает синтаксис и возможности языка ProbabilityScript, архитектуру реализации интерпретатора, пример использования языка, а также содержит заключение с выводами и возможными направлениями развития. В приложении приведён полный листинг демонстрационного сценария \texttt{demo\_basic.psc}, иллюстрирующего основные возможности языка.

\section{Синтаксис языка ProbabilityScript}
Данный раздел описывает синтаксис и ключевые возможности языка сценариев ProbabilityScript. Язык имеет минималистичный синтаксис и предназначен для генерации случайных чисел, повторения серии экспериментов и сбора статистики. Основной (и единственный) тип данных в языке -- вещественное число с плавающей запятой (floating point). Ниже рассматриваются типы данных, конструкции языка, встроенные функции и приводятся примеры сценариев.

\subsection{Типы данных}
В языке ProbabilityScript используется один базовый тип данных:
\begin{itemize}
    \item \textbf{Вещественные числа:} все переменные и выражения являются числовыми (тип с плавающей запятой, обычно двойной точности). Целочисленные значения не выделяются отдельно, а представляют собой частный случай вещественного. Строковые значения и логические типы в текущей версии языка не поддерживаются.
\end{itemize}
Переменные в сценарии не объявляются заранее -- они неявно создаются при первом присваивании. Имена переменных могут состоять из букв латинского алфавита и цифр, начинаются с буквы. Например, допустимы имена \texttt{x}, \texttt{value1}, \texttt{sum}.

\subsection{Конструкции языка}
Язык сценариев предоставляет небольшой набор управляющих конструкций и инструкций:
\begin{itemize}
    \item \textbf{Присваивание.} Оператор \texttt{=} используется для присваивания значения переменной. Слева от \texttt{=} указывается имя переменной, справа -- выражение. Присваивание инициализирует новую переменную или обновляет значение существующей. Примеры: \texttt{x = 5} (присвоить 5 переменной \texttt{x}); \texttt{y = x + 1.5} (вычислить выражение и сохранить в \texttt{y}).
    \item \textbf{Цикл \texttt{repeat}.} Конструкция повторения имеет синтаксис: \texttt{repeat $N$ \{ ... \}}, где $N$ -- целочисленное количество итераций (задается как числовое выражение). Блок в фигурных скобках повторяется $N$ раз. Обычно цикл \texttt{repeat} используется для выполнения серии случайных экспериментов. Вложенные циклы \texttt{repeat} не предусмотрены.
    \item \textbf{Инструкция \texttt{collect}.} Внутри цикла можно использовать инструкцию \texttt{collect $E$}, где $E$ -- числовое выражение. Эта инструкция собирает (накапливает) значение выражения $E$ в специальную выборку результатов. По завершении цикла собранные данные могут быть использованы для вычисления статистических показателей. Например, \texttt{collect x} сохранит текущее значение переменной \texttt{x} в набор результатов.
    \item \textbf{Вывод \texttt{print}.} Инструкция \texttt{print $E$} выводит значение выражения $E$ на экран (в стандартный вывод). Можно использовать \texttt{print} для отображения числовых результатов или сообщений. Каждое выполнение \texttt{print} выводит значение (возможно, с новой строки). Например, \texttt{print x} выведет текущее значение \texttt{x}. При необходимости, можно выводить также простой текст (строковые литералы в кавычках) для пояснения результатов, однако переменные строкового типа не поддерживаются.
    \item \textbf{Вывод статистики \texttt{print\_stat}.} Эта инструкция выводит сводную статистику по ранее собранной выборке данных (через \texttt{collect}). При выполнении \texttt{print\_stat} интерпретатор рассчитывает и печатает основные показатели: размер выборки (\texttt{count}), среднее значение (\texttt{mean}), дисперсию (\texttt{variance}), стандартное отклонение (\texttt{stddev}) и медиану (\texttt{median}). Формат вывода представляет собой перечень этих статистик с их значениями. Инструкцию \texttt{print\_stat} обычно вызывают после цикла, когда все данные собраны.
\end{itemize}

Блоки кода ограничиваются фигурными скобками \texttt{\{\}}. Каждая инструкция (присваивание, collect, print и т.д.) записывается с новой строки (точка с запятой в конце строк не требуется). Отступы и пробелы вне строк не влияют на выполнение (но рекомендуется использовать отступы внутри блока \texttt{repeat} для читаемости). 

\subsection{Встроенные функции}
Для организации вероятностных экспериментов и статистической обработки в языке ProbabilityScript доступны следующие встроенные функции:
\begin{itemize}
    \item \textbf{\texttt{uniform($a$, $b$)}} – возвращает псевдослучайное вещественное число, равномерно распределённое в интервале $[a, b]$. Каждый вызов генерирует новое случайное значение. Например, \texttt{x = uniform(0, 1)} присвоит \texttt{x} случайное число из диапазона $0$ до $1$.
    \item \textbf{\texttt{normal($\mu$, $\sigma$)}} – возвращает случайное вещественное число из нормального распределения $N(\mu, \sigma)$ с заданным математическим ожиданием $\mu$ и среднеквадратическим отклонением $\sigma$. Например, \texttt{y = normal(5, 2)} сгенерирует значение, распределённое нормально со средним $5$ и стандартным отклонением $2$.
    \item \textbf{\texttt{mean()}} – вычисляет и возвращает среднее значение (математическое ожидание) по текущей собранной выборке данных (т.е. по всем значениям, накопленным с помощью \texttt{collect} на данном этапе исполнения сценария). Обычно вызывается после цикла, когда доступны результаты. Если выборка пуста (не было \texttt{collect}), \texttt{mean()} может вернуть 0 или вызвать ошибку (в текущей реализации предполагается, что \texttt{mean()} вызывается корректно после сбора данных).
    \item \textbf{\texttt{variance()}} – вычисляет дисперсию текущей выборки. Формула расчёта – обычная выборочная дисперсия по собранным данным. Возвращает числовое значение дисперсии. Аналогично \texttt{mean()}, предполагается вызов после сбора данных.
    \item \textbf{\texttt{stddev()}} – вычисляет стандартное отклонение текущей выборки. По сути, это квадратный корень из значения \texttt{variance()}. Возвращает положительное вещественное число.
    \item \textbf{\texttt{median()}} – вычисляет медиану текущей выборки. При чётном количестве элементов берётся среднее арифметическое двух центральных значений, при нечётном – средний элемент после сортировки выборки. Возвращает вещественное значение медианы.
    \item \textbf{\texttt{count()}} – возвращает размер (мощность) текущей выборки, т.е. количество значений, добавленных через \texttt{collect}. Может быть полезно, например, для вывода количества итераций или проверки, сколько данных собрано.
\end{itemize}

Вышеописанные функции (\texttt{mean}, \texttt{variance}, \texttt{stddev}, \texttt{median}, \texttt{count}) обычно используются либо в составе инструкции \texttt{print} для вывода, либо в выражениях присваивания, если требуется сохранить результат вычисления в переменной для дальнейших расчётов.

\subsection{Примеры сценариев}
Ниже приведены два примера использования ProbabilityScript с пояснениями.

\medskip
\noindent\textbf{Пример 1. Оценка характеристик равномерного распределения.} В первом сценарии моделируется генерация выборки из равномерного распределения на интервале $[0,1]$ и последующий расчёт статистических характеристик этой выборки. Сценарий проводит 100 испытаний, собирает результаты и выводит рассчитанные величины (среднее, дисперсию, медиану и т.д.) с помощью \texttt{print\_stat}.

\begin{lstlisting}
N = 100
repeat N {
    x = uniform(0, 1)
    collect x
}
print_stat("mean")
print_stat("variance")
print_stat("median")
\end{lstlisting}

В этом примере на каждой итерации цикла \texttt{repeat} генерируется случайное число \texttt{x} из диапазона $0$ до $1$ и оно сохраняется инструкцией \texttt{collect}. После завершения 100 повторений команда \texttt{print\_stat} выводит количество сгенерированных значений (должно быть 100), а также рассчитанное среднее (ожидаемо около $0.5$), дисперсию (теоретически $1/12 \approx 0.083$), стандартное отклонение (около $0.29$) и медиану (около $0.5$). Фактические значения будут немного отличаться из-за случайной природы генератора, но при большом числе итераций они стремятся к теоретическим. 

\medskip
\noindent\textbf{Пример 2. Оценка характеристик нормального распределения.} Во втором сценарии генерируется выборка из нормального распределения $N(0,1)$ (стандартное нормальное распределение) и вычисляются статистики выборки. Ожидается, что среднее будет близко к $0$, а стандартное отклонение близко к $1$.

\begin{lstlisting}
N = 50
repeat N {
    y = normal(0, 1)
    collect y
}
print mean()
print stddev()
\end{lstlisting}

В данном примере сценарий выполняет 50 испытаний, в каждой итерации получая случайное значение \texttt{y} из нормального распределения с $\mu=0$ и $\sigma=1$. Значения накапливаются, после чего с помощью \texttt{print} выводятся вычисленное выборочное среднее и выборочное стандартное отклонение. (Для наглядности в этом примере использована \texttt{print} с текстовыми пояснениями; вывод может выглядеть, например, как \texttt{Mean of sample: -0.1} и \texttt{Stddev of sample: 0.9}, в зависимости от сгенерированных данных.) При достаточном количестве итераций результаты приближаются к заданным параметрам распределения.

\section{Архитектура реализации}
Реализация интерпретатора ProbabilityScript основана на классической структуре интерпретируемого языка: входной сценарий последовательно проходит этапы лексического анализа, синтаксического анализа (разбора), построения внутреннего представления и непосредственного исполнения. Основные компоненты системы: лексер, парсер, дерево разбора (AST), интерпретатор, среда выполнения и модуль статистики. Ниже описаны функции каждого модуля и процесс выполнения сценария.

\subsection{Модули интерпретатора}
Основные модули, из которых состоит интерпретатор ProbabilityScript:
\begin{itemize}
    \item \textbf{Лексер (Lexer).} Отвечает за лексический анализ входного текста сценария. На этом этапе исходный код, представленный последовательностью символов, преобразуется в поток токенов. Токены — это значимые единицы текста: ключевые слова (\texttt{repeat}, \texttt{collect}, \texttt{print} и т.д.), идентификаторы (имена переменных и функций), числовые литералы, специальные символы (фигурные скобки, знаки операций, запятые и пр.). Лексер проходит по тексту, распознаёт токены и передаёт их парсеру. При обнаружении неизвестных последовательностей символов или ошибок формата лексер генерирует ошибку (например, недопустимый символ).
    \item \textbf{Парсер (Parser).} Выполняет синтаксический разбор последовательности токенов, полученных от лексера, и строит \textbf{абстрактное синтаксическое дерево (AST)} программы. Парсер проверяет правильность конструкции сценария согласно грамматике языка ProbabilityScript (например, корректное использование \texttt{repeat}-блоков, правильное расположение инструкций внутри них, наличие выражения после \texttt{collect} и т.д.). Если входная последовательность токенов не соответствует ожидаемой структуре (синтаксическая ошибка), парсер выдаёт сообщение об ошибке и выполнение программы прекращается. В случае успешного разбора результатом является AST — иерархическая структура, отражающая программу.
    \item \textbf{Абстрактное синтаксическое дерево (AST).} Внутреннее представление сценария в памяти. AST состоит из узлов, каждый из которых соответствует языковой конструкции: узлы для выражений (например, бинарная операция, вызов функции \texttt{uniform()}), узел для присваивания, узел цикла \texttt{repeat}, узел инструкции \texttt{collect}, узел \texttt{print} и т.д. Дерево отражает вложенность блоков (узел \texttt{repeat} содержит подузлы — тело цикла). Это представление удобно для последующей интерпретации: обходя AST, интерпретатор выполняет программу.
    \item \textbf{Интерпретатор.} Модуль, выполняющий построковый обход/обход дерева AST и непосредственное исполнение команд сценария. Интерпретатор реализует логику работы каждого типа узла: при встрече узла-присваивания он вычисляет выражение и сохраняет значение переменной в среде выполнения; узел \texttt{repeat} приводит к циклическому выполнению поддерева определённое число раз; узел \texttt{collect} вызывает добавление значения в статистическую выборку; узлы \texttt{print} и \texttt{print\_stat} инициируют вывод. Интерпретатор также обрабатывает вызовы встроенных функций (\texttt{uniform}, \texttt{normal} и др.), вызывая соответствующие процедуры из модуля статистики или стандартной библиотеки.
    \item \textbf{Среда выполнения (Environment).} Этот компонент хранит текущее состояние исполняемого сценария: значения переменных, а также контекст для генерации случайных чисел и сбора статистики. По сути, среда представляет собой таблицу символов (имён переменных) и их значений, которая изменяется по мере выполнения программы (при присваивании создаются новые пары «имя-значение» или обновляются существующие). Кроме того, среда может содержать структуру для хранения собранных данных (например, массив или список чисел, в который \texttt{collect} добавляет элементы). Реализация генератора случайных чисел (для \texttt{uniform}, \texttt{normal}) также привязана к среде: обычно в среде хранения находится объект генератора (например, на базе Mersenne Twister или другого алгоритма) и, при необходимости, текущее состояние случайных последовательностей.
    \item \textbf{Модуль статистики.} Предоставляет функции для обработки собранных данных. В простейшем случае, функции \texttt{mean()}, \texttt{variance()}, \texttt{stddev()}, \texttt{median()}, \texttt{count()} могут быть реализованы непосредственно внутри интерпретатора. Однако более модульно выносить их в отдельный компонент. Модуль статистики оперирует над выборкой, накопленной средой выполнения. Например, при вызове \texttt{mean()} интерпретатор обращается к функции \texttt{mean} из данного модуля, передавая ей доступ к списку собранных значений; функция рассчитывает среднее (суммирует все элементы и делит на количество). Аналогично вычисляются и другие показатели. Некоторые из этих функций требуют сортировки выборки (например, для медианы) или нескольких проходов по данным (для дисперсии и стандартного отклонения). Модуль статистики инкапсулирует эти алгоритмы, возвращая готовые результаты интерпретатору.
\end{itemize}

\subsection{Путь от сценария до исполнения}
После запуска интерпретатора (команды \texttt{psc}) с указанием сценария ProbabilityScript, выполнение происходит по следующим этапам:
\begin{enumerate}
    \item \textbf{Чтение файла сценария.} Программа-интерпретатор открывает файл с расширением \texttt{.psc}, загружает всё содержимое сценария в память как текст.
    \item \textbf{Лексический анализ.} Текст сценария передается лексеру. Лексер считывает символы и преобразует исходный код в токены. Например, строка \texttt{repeat 10 \{} будет преобразована в последовательность токенов \{\texttt{KEYWORD\_REPEAT}, \texttt{NUMBER(10)}, \texttt{LBRACE}\}. Результат работы лексера — список токенов, представляющий весь файл сценария.
    \item \textbf{Синтаксический анализ и построение AST.} Список токенов поступает парсеру. Парсер последовательно считывает токены и сопоставляет им правила грамматики. При обнаружении конструкций (например, ключевое слово \texttt{repeat} указывает, что далее должен следовать числовой параметр и блок в фигурных скобках) парсер создаёт соответствующие узлы AST и выстраивает иерархию. К концу разбора строится корневой AST-узел, содержащий весь сценарий (например, последовательность инструкций верхнего уровня, в том числе, возможно, цикл \texttt{repeat}). Если на этом шаге встречается ошибка (неправильный порядок токенов, отсутствующая закрывающая скобка и т.п.), выполнение прерывается с сообщением об ошибке синтаксиса.
    \item \textbf{Интерпретация (исполнение).} Полученное абстрактное синтаксическое дерево передается в интерпретатор. Интерпретатор выполняет рекурсивный обход дерева. Начинается выполнение с корневого узла (например, если программа состоит из последовательности инструкций, они выполняются по порядку). При входе в узел цикла \texttt{repeat} интерпретатор повторяет интерпретацию вложенных узлов заданное число раз. Узлы присваивания вызывают вычисление выражения (это может рекурсивно обходить поддерево выражения) и сохранение результата в среде. Вызов \texttt{uniform} или \texttt{normal} приводит к обращению к генератору случайных чисел: интерпретатор передаёт параметры в функцию генерации и получает случайное значение. Инструкция \texttt{collect} заставляет интерпретатор добавить текущий результат в массив/список хранимых данных (в среде). При встрече узла \texttt{print} интерпретатор вычисляет выражение и выводит полученное значение на консоль (через стандартный вывод). Для \texttt{print\_stat} интерпретатор запрашивает у модуля статистики вычисление всех необходимых величин по накопленной выборке и выводит их в понятном формате. 
    \item \textbf{Завершение работы.} После обхода всего AST сценарий считается исполненным. Интерпретатор освобождает занятые ресурсы (например, очищает использованные структуры, закрывает файл, если это не сделано ранее). При корректном завершении работы возвращается код успеха (0). В случае ошибок на любом из этапов (лексическом, синтаксическом или во время выполнения, например, деление на ноль или вызов статистической функции без данных) интерпретатор выводит сообщение об ошибке с указанием ее типа и, по возможности, позиции в тексте сценария, после чего завершает работу с кодом ошибки.
\end{enumerate}

\section{Пример использования}
Рассмотрим, как на практике использовать разработанный язык ProbabilityScript и его интерпретатор. Ниже описаны шаги создания и запуска сценария, установки генератора случайных чисел в детерминированное состояние и анализ полученного вывода.

\begin{enumerate}
    \item \textbf{Подготовка сценария.} Сценарий пишется в обычном текстовом файле с расширением \texttt{.psc}. В файле содержится код на языке ProbabilityScript. Например, можно создать файл \texttt{demo\_basic.psc} со сценарием, демонстрирующим генерацию 100 случайных чис и вывод статистики (полный текст сценария приведён в Приложении).
    \item \textbf{Запуск интерпретатора.} Для выполнения сценария используется консольная утилита-интерпретатор \texttt{psc}. Запуск производится командой в терминале, указывающей имя файла сценария. Пример команды (в текущем каталоге с файлом):
\begin{verbatim}
$ psc demo_basic.psc
\end{verbatim}
    После запуска программа \texttt{psc} прочитает файл, обработает сценарий и начнёт его выполнение. В процессе выполнения на консоль будут выводиться результаты согласно инструкциям \texttt{print} и \texttt{print\_stat} внутри сценария.
    \item \textbf{Установка зерна генератора случайностей.} По умолчанию генерация случайных чис (\texttt{uniform}, \texttt{normal}) каждый раз происходит с новой случайной последовательностью. Для воспроизводимости результатов предусмотрен специальный параметр командной строки \texttt{--seed}. Его можно указать при запуске интерпретатора, чтобы задать начальное значение (seed) для генератора случайных чис. При одном и том же seed последовательность генерируемых чисел будет идентичной на разных запусках, что удобно для отладки. Пример запуска с указанием зерна:
\begin{verbatim}
$ psc demo_basic.psc --seed=42
\end{verbatim}
    В данном случае генератор случайных чис инициализируется значением 42, и сценарий \texttt{demo\_basic.psc} каждый раз будет давать один и тот же последовательный набор псевдослучайных чис.
    \item \textbf{Анализ вывода.} После успешного исполнения сценария на консоль выводятся результаты, сформированные инструкциями \texttt{print}/\texttt{print\_stat}. Например, для сценария \texttt{demo\_basic.psc} (как в Примере 1) вывод может выглядеть следующим образом (при фиксированном зерне для наглядности):
\begin{verbatim}
Count:    100
Mean:     0.480
Variance: 0.086
Stddev:   0.294
Median:   0.482
\end{verbatim}
    Здесь \texttt{Count} обозначает количество собранных значений (100 итераций), а остальные строки отображают статистические показатели выборки (среднее ~0.480, дисперсия ~0.086, стандартное отклонение ~0.294, медиана ~0.482). Пользователь может сопоставить эти результаты с теоретическими ожиданиями или использовать их для дальнейшего анализа. При каждом новом запуске без фиксированного зерна значения будут отличаться случайным образом, но остаются в разумных пределах для равномерного распределения на $[0,1]$.
\end{enumerate}

\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В рамках данного проекта разработан и реализован простой интерпретируемый язык сценариев \textbf{ProbabilityScript} для задач вероятностного моделирования. Язык поддерживает генерацию случайных чисел из базовых распределений (равномерного и нормального), повторение серий экспериментов с накоплением результатов, вычисление основных статистических характеристик выборки, а также вывод результатов на экран. Реализована основная инфраструктура интерпретатора: лексер, парсер, AST, интерпретатор, управление средой выполнения и базовый модуль статистики.

Данный язык можно расширять и улучшать. В будущем планируется добавить новые типы распределений (например, экспоненциальное, биномиальное и др.), а также поддерживать более сложные конструкции языка. Полезным развитием было бы введение условных операторов (\texttt{if/else}) и циклов с условием (\texttt{while}), что расширило бы класс моделируемых задач. Можно рассмотреть введение разных типов данных (например, целых чисел, булевых значений для условий, либо простых структур данных для хранения нескольких выборок). Ещё одним направлением развития является вывод результатов в файл или визуализация распределений. Тем не менее, даже текущая версия ProbabilityScript демонстрирует работоспособность подхода: компактный язык позволяет пользователю быстро описать и выполнить вероятностный эксперимент, получив основные характеристики распределения без необходимости программировать эти вычисления с нуля в языках общего назначения.

\appendix
\section*{Приложение: Полный листинг сценария \texttt{demo\_basic.psc}}
\addcontentsline{toc}{section}{Приложение: Листинг сценария demo\_basic.psc}
Ниже приведён полный исходный код сценария \texttt{demo\_basic.psc}, иллюстрирующего базовое использование языка ProbabilityScript (генерация 100 равномерных случайных чисел на интервале $[0,1]$ и вывод статистических показателей). Этот сценарий использовался в качестве примера в тексте отчёта.

\begin{lstlisting}
# demo_basic.psc

N = 100
repeat N {
    x = uniform(0, 1)
    collect x
}
print_stat("count")
print_stat("mean")
print_stat("variance")
print_stat("stddev")
print_stat("median")
\end{lstlisting}

\end{document}